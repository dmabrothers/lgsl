<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Fast Fourier Transform &mdash; Documentation for LGSL v0.1</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Documentation for LGSL v0.1" href="index.html" />
    <link rel="next" title="Ordinary Differential Equations" href="ode.html" />
    <link rel="prev" title="Basis Splines" href="bsplines.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ode.html" title="Ordinary Differential Equations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="bsplines.html" title="Basis Splines"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Documentation for LGSL v0.1</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-fft"></span><div class="section" id="fast-fourier-transform">
<h1>Fast Fourier Transform<a class="headerlink" href="#fast-fourier-transform" title="Permalink to this headline">¶</a></h1>
<div class="section" id="mathematical-definitions">
<h2>Mathematical Definitions<a class="headerlink" href="#mathematical-definitions" title="Permalink to this headline">¶</a></h2>
<p>Fast Fourier Transforms are efficient algorithms for calculating the discrete Fourier transform (DFT)</p>
<div class="math">
\[x_j = \sum_{k=0}^{n-1} z_k \exp(-2\pi i j k / n)\]</div>
<p>The DFT usually arises as an approximation to the continuous Fourier
transform when functions are sampled at discrete intervals in space or
time. The naive evaluation of the discrete Fourier transform is a matrix-vector multiplication <span class="math">\(W\vec{z}\)</span>. A general matrix-vector multiplication takes O(n<sup>2</sup>) operations for n data-points. Fast Fourier transform algorithms use a divide-and-conquer strategy to factorize the matrix W into smaller sub-matrices, corresponding to the integer factors of the length n. If n can be factorized into a product of integers f<sub>1</sub> f<sub>2</sub> ... f<sub>m</sub> then the DFT can be computed in O(<span class="math">\(n \sum f_i\)</span>) operations. For a radix-2 FFT this gives an operation count of O(n log<sub>2</sub> n).</p>
<p>All the FFT functions offer two types of transform: forwards and inverse, based on the same mathematical definitions. The definition of the forward Fourier transform, <tt class="docutils literal"><span class="pre">fft(z)</span></tt>, is,</p>
<div class="math">
\[x_j = \sum_{k=0}^{n-1} z_k \exp(-2\pi i j k / n)\]</div>
<p>and the definition of the inverse Fourier transform is,</p>
<div class="math">
\[z_j = {1 \over n} \sum_{k=0}^{n-1} x_k \exp(2\pi i j k / n).\]</div>
<p>The factor of 1/n makes this a true inverse.</p>
<p>In general there are two possible choices for the sign of the exponential in the transform/ inverse-transform pair.
GSL follows the same convention as fftpack, using a negative exponential for the forward transform.
The advantage of this convention is that the inverse transform recreates the original function with simple Fourier synthesis.
Numerical Recipes uses the opposite convention, a positive exponential in the forward transform.</p>
</div>
<div class="section" id="lgsl-interface">
<h2>LGSL interface<a class="headerlink" href="#lgsl-interface" title="Permalink to this headline">¶</a></h2>
<p>LGSL provides a simple interface to perform Fourier transforms of real data with the functions <a class="reference internal" href="#fft.fft" title="fft.fft"><tt class="xref py py-func docutils literal"><span class="pre">fft.fft()</span></tt></a> and <a class="reference internal" href="#fft.fftinv" title="fft.fftinv"><tt class="xref py py-func docutils literal"><span class="pre">fft.fftinv()</span></tt></a>.
The first function performs the Fourier transform of a column matrix and the second is the inverse Fourier transform.</p>
<p>The function <a class="reference internal" href="#fft.fft" title="fft.fft"><tt class="xref py py-func docutils literal"><span class="pre">fft.fft()</span></tt></a> returns a half-complex array.
The latter is similar to a column matrix of complex numbers, but it is actually a different object because the numbers are packed together following some specific rules related to the algorithm.</p>
<p>The idea is that you can access the elements of this vector for reading or writing simply by indexing it.
You can also obtain the size of the vector using the operator &#8216;#&#8217;.
The valid indices for a half-complex object range from 0 to N-1 where N is the size if the vector.
Each element of the vector corresponds to the coefficient <span class="math">\(z_k\)</span> defined above.</p>
<p>When performing Fourier transforms, it is important to know that the computation speed can be greatly influenced by the size of the vector. If the size is a power of two, a very efficient algorithm can be used and we can talk in this case of a Fast Fourier Transform (FFT). In addition, the algorithm has the advantage that it does not require any additional workspace. When the size of the vector is not a power of two, we can have two different cases:</p>
<blockquote>
<div><ul class="simple">
<li>the size is a product of small prime numbers</li>
<li>the size contains a big (&gt; 7) prime number in its factorization</li>
</ul>
</div></blockquote>
<p>This detail is important because if the size is a product of small prime numbers, a fast algorithm is still available but it is still somewhat slower and it does require some additional workspace.
In the worst case when the size cannot be factorized to small prime numbers, the Fourier transform can still be computed but the calculation is slower, especially for large arrays.</p>
<p>LGSL hides all the details and takes care of choosing the appropriate algorithm based on the size of the vector.
It also transparently provides any additional workspace that may be needed for the algorithm.
In order to avoid repeated allocation of workspace memory, the workspace allocated is kept in memory and reused <em>if the size of the array does not change</em>.
This means that the approach of LGSL is quite optimal if you perform many Fourier transforms (direct or inverse) of the same size.</p>
<p>Even though LGSL takes care of the details automatically, you should be aware of these performance notices because it can make a big difference in real applications.
From a practical point of view, it is useful in most cases to always provide samples whose size is a power of two.</p>
<p>Another property of the functions <a class="reference internal" href="#fft.fft" title="fft.fft"><tt class="xref py py-func docutils literal"><span class="pre">fft.fft()</span></tt></a> and <a class="reference internal" href="#fft.fftinv" title="fft.fftinv"><tt class="xref py py-func docutils literal"><span class="pre">fft.fftinv()</span></tt></a> is that they can optionally perform the transformation <em>in place</em> by modifying the original data instead of creating a copy.
When a transformation <em>in place</em> is requested, the routine still returns a new vector (either a real matrix or a half-complex array) but this latter will point to the same underlying data of the original vector.
The transformation <em>in place</em> can be useful in some cases to avoid unnecessary data copying and memory allocation.</p>
</div>
<div class="section" id="fourier-transform-of-real-data">
<h2>Fourier Transform of Real Data<a class="headerlink" href="#fourier-transform-of-real-data" title="Permalink to this headline">¶</a></h2>
<p>For real data, the Fourier coefficients satisfy the relation</p>
<div class="math">
\[z_k = z_{N-k}^*\]</div>
<p>where N is the size of the vector and k is any integer number from 0 to N-1.
Because of this relation, the data is packed in a special type of object called a half-complex array.</p>
<p>To access an element in a half-complex array, you can index it with an integer number between 0 and N-1, inclusive. So, for example:</p>
<div class="highlight-lua"><div class="highlight"><pre><span class="c1">-- Load all modules in a table called lgsl</span>
<span class="n">lgsl</span> <span class="o">=</span> <span class="nb">require</span><span class="p">(</span><span class="s2">&quot;</span><span class="s">lgsl&quot;</span><span class="p">)</span>

<span class="c1">-- get a random number generator</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">lgsl</span><span class="p">.</span><span class="n">rng</span><span class="p">.</span><span class="n">new</span><span class="p">()</span>

<span class="c1">-- create a vector with random numbers</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">lgsl</span><span class="p">.</span><span class="n">matrix</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span> <span class="k">return</span> <span class="n">lgsl</span><span class="p">.</span><span class="n">rnd</span><span class="p">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">end</span><span class="p">)</span>

<span class="c1">-- take the Fourier transform</span>
<span class="n">ft</span> <span class="o">=</span> <span class="n">lgsl</span><span class="p">.</span><span class="n">fft</span><span class="p">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1">-- print all the coefficients of the Fourier transform</span>
<span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">#</span><span class="n">ft</span><span class="o">-</span><span class="mi">1</span> <span class="k">do</span> <span class="nb">print</span><span class="p">(</span><span class="n">ft</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">end</span>
</pre></div>
</div>
<p>As shown in the example above, you can use the Lua operator &#8216;#&#8217; to obtain the size of a half-complex array.</p>
<dl class="function">
<dt id="fft.fft">
<tt class="descclassname">fft.</tt><tt class="descname">fft</tt><big>(</big><em>v</em><span class="optional">[</span>, <em>in_place</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#fft.fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the Fourier transform of the real-valued column matrix <tt class="docutils literal"><span class="pre">v</span></tt>.
If <tt class="docutils literal"><span class="pre">in_place</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt> then the original data is altered and the resulting vector will point to the same underlying data of the original vector.</p>
<p>Please note that the value you obtain is not an ordinary matrix but a half-complex array.
You can access the elements of such an array by indexing the vector.
If you want to have an ordinary matrix you can easily build it with the following instructions:</p>
<div class="highlight-lua"><div class="highlight"><pre><span class="c1">-- we suppose that ft is an half-complex array</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">lgsl</span><span class="p">.</span><span class="n">matrix</span><span class="p">.</span><span class="n">cnew</span><span class="p">(</span><span class="o">#</span><span class="n">ft</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">return</span> <span class="n">ft</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">end</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="fft.fftinv">
<tt class="descclassname">fft.</tt><tt class="descname">fftinv</tt><big>(</big><em>hc</em><span class="optional">[</span>, <em>in_place</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#fft.fftinv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a column matrix that contains the inverse Fourier transform of the half-complex vector <tt class="docutils literal"><span class="pre">hc</span></tt>.
If <tt class="docutils literal"><span class="pre">in_place</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt> then the original data is altered and the resulting vector will point to the same underlying data of the original vector.</p>
<p>This transformation is the inverse of the function <a class="reference internal" href="#fft.fft" title="fft.fft"><tt class="xref py py-func docutils literal"><span class="pre">fft.fft()</span></tt></a>, so that if you perform the two transformations consecutively you will obtain a vector identical to the initial one.</p>
<p>A typical usage of <tt class="xref py py-func docutils literal"><span class="pre">fft.fft_inv()</span></tt> is to revert the transformation made with <a class="reference internal" href="#fft.fft" title="fft.fft"><tt class="xref py py-func docutils literal"><span class="pre">fft.fft()</span></tt></a> but by doing some transformations along the way, such as applying a filter.
So a typical usage path could be:</p>
<div class="highlight-lua"><div class="highlight"><pre><span class="c1">-- we assume v is a column matrix with our data</span>
<span class="n">ft</span> <span class="o">=</span> <span class="n">fft</span><span class="p">.</span><span class="n">fft</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="c1">-- Fourier transform</span>

<span class="c1">-- here we can manipulate the half-complex array &#39;ft&#39;</span>
<span class="c1">-- using the methods `get&#39; and `set&#39;</span>

<span class="n">vt</span> <span class="o">=</span> <span class="n">fft</span><span class="p">.</span><span class="n">fftinv</span><span class="p">(</span><span class="n">ft</span><span class="p">)</span> <span class="c1">-- we perform the inverse Fourier transform</span>
<span class="c1">-- now vt is a vector of the same size of v</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="fft-example">
<h2>FFT example<a class="headerlink" href="#fft-example" title="Permalink to this headline">¶</a></h2>
<p>In this example we will treat a square pulse in the temporal domain. To illustrate a typical example of FFT usage we perform the Fourier Transform of the signal and we cut the higher order frequencies. Then we perform the inverse transform and we compare the result with the original time signal.</p>
<p>So, first we define our square pulse in the time domain. Actually it will be a matrix with just one column:</p>
<div class="highlight-lua"><div class="highlight"><pre><span class="n">matrix</span> <span class="o">=</span> <span class="nb">require</span><span class="p">(</span><span class="s2">&quot;</span><span class="s">lgsl.matrix&quot;</span><span class="p">)</span>
<span class="n">fft</span> <span class="o">=</span> <span class="nb">require</span><span class="p">(</span><span class="s2">&quot;</span><span class="s">lgsl.fft&quot;</span><span class="p">)</span>

<span class="n">n</span><span class="p">,</span> <span class="n">ncut</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">16</span>

<span class="c1">-- we create a pulse signal in the time domain</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">return</span>  <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">/</span><span class="mi">3</span> <span class="ow">and</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="mi">3</span> <span class="ow">and</span> <span class="mi">1</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span> <span class="k">end</span> <span class="p">)</span>
</pre></div>
</div>
<p>If we have <a class="reference external" href="http://franko.github.io/graph-toolkit/graphics.html#graphics-chapter" title="(in Lua Graphics Toolkit v1.0)"><em class="xref std std-ref">graph-toolkit</em></a> available, we can create two new plots, one for the Fourier transform and one for the signal itself:</p>
<div class="highlight-lua"><div class="highlight"><pre><span class="n">graph</span> <span class="o">=</span> <span class="nb">require</span><span class="p">(</span><span class="s2">&quot;</span><span class="s">graph&quot;</span><span class="p">)</span>
<span class="n">pt</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="s1">&#39;</span><span class="s">Original signal / reconstructed&#39;</span><span class="p">)</span>

<span class="n">pt</span><span class="p">:</span><span class="n">addline</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">filine</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">return</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">end</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="s1">&#39;</span><span class="s">black&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we are ready to perform:</p>
<blockquote>
<div><ul class="simple">
<li>the Fourier transform</li>
<li>cut the higher frequencies</li>
<li>transform back the signal in the time domain</li>
</ul>
</div></blockquote>
<p>and plot the results:</p>
<div class="highlight-lua"><div class="highlight"><pre><span class="n">ft</span> <span class="o">=</span> <span class="n">fft</span><span class="p">.</span><span class="n">fft</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

<span class="n">complex</span> <span class="o">=</span> <span class="nb">require</span><span class="p">(</span><span class="s2">&quot;</span><span class="s">lgsl.complex&quot;</span><span class="p">)</span>
<span class="n">pf</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">fibars</span><span class="p">(</span> <span class="k">function</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">return</span> <span class="n">complex</span><span class="p">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ft</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">end</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
<span class="n">pf</span><span class="p">.</span><span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="s">FFT Power Spectrum&#39;</span>

<span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="n">ncut</span><span class="p">,</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span> <span class="k">do</span> <span class="n">ft</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">end</span>
<span class="n">ytr</span> <span class="o">=</span> <span class="n">fft</span><span class="p">.</span><span class="n">fftinv</span><span class="p">(</span><span class="n">ft</span><span class="p">)</span>

<span class="n">pt</span><span class="p">:</span><span class="n">addline</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">filine</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">return</span> <span class="n">ytr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">end</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="s1">&#39;</span><span class="s">red&#39;</span><span class="p">)</span>

<span class="n">pt</span><span class="p">:</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure">
<img alt="_images/fft-example-power-spectrum.png" src="_images/fft-example-power-spectrum.png" />
<p class="caption">Fourier transform spectrum</p>
</div>
<div class="figure">
<img alt="_images/fft-example-time-signal.png" src="_images/fft-example-time-signal.png" />
<p class="caption">Time signal before (black) and after (red) the transformation</p>
</div>
<p>You can observe in the reconstructed signal (the red curve) that we obtain approximately the square pulse, but with a lot of oscillations. These oscillations are an artifact of our transformations, sometimes referred to as the Gibbs phenomenon. The reason is that in order to perfectly reproduce a sharp signal, we would need an infinite number of frequencies in the Fourier transform.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Fast Fourier Transform</a><ul>
<li><a class="reference internal" href="#mathematical-definitions">Mathematical Definitions</a></li>
<li><a class="reference internal" href="#lgsl-interface">LGSL interface</a></li>
<li><a class="reference internal" href="#fourier-transform-of-real-data">Fourier Transform of Real Data</a></li>
<li><a class="reference internal" href="#fft-example">FFT example</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="bsplines.html"
                        title="previous chapter">Basis Splines</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="ode.html"
                        title="next chapter">Ordinary Differential Equations</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/fft.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ode.html" title="Ordinary Differential Equations"
             >next</a> |</li>
        <li class="right" >
          <a href="bsplines.html" title="Basis Splines"
             >previous</a> |</li>
        <li><a href="index.html">Documentation for LGSL v0.1</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2016, Francesco Abbate, Lesley De Cruz, Benjamin von Ardenne.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>